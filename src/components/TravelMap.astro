---
import travel from '../data/travel.json';
import { feature } from 'topojson-client';
import { geoEqualEarth, geoPath } from 'd3-geo';
import countries from 'world-atlas/countries-110m.json';
import isoCountries from 'i18n-iso-countries';
import enLocale from 'i18n-iso-countries/langs/en.json';

isoCountries.registerLocale(enLocale);

const totalCountries = 195;
const visitedCount = travel.countriesVisited.length;
const progressPercent = Math.round((visitedCount / totalCountries) * 100);

const world = feature(countries, countries.objects.countries);
const width = 1000;
const height = 520;
const projection = geoEqualEarth().fitSize([width, height], world);
const path = geoPath(projection);

const visitedIds = new Set(
  travel.countriesVisited
    .map((country) => Number(isoCountries.alpha2ToNumeric(country.code)))
    .filter((id) => Number.isFinite(id))
);

const cityMarkers = [...travel.citiesLived, ...(travel.cityNotes ?? [])];
const duplicateOffsets = new Map();
const markers = cityMarkers
  .map((city, index) => {
    const coords = projection([city.lon, city.lat]);
    if (!coords) return null;
    const key = `${city.lat},${city.lon}`;
    const offset = duplicateOffsets.get(key) || 0;
    duplicateOffsets.set(key, offset + 1);
    const jitter = offset * 6;
    return {
      ...city,
      id: `city-${index}`,
      x: coords[0] + jitter,
      y: coords[1] - jitter,
    };
  })
  .filter(Boolean);

const countryNotesById = new Map(
  (travel.countryNotes ?? [])
    .map((note) => ({
      ...note,
      id: Number(isoCountries.alpha2ToNumeric(note.code)),
    }))
    .filter((note) => Number.isFinite(note.id))
    .map((note) => [note.id, note])
);

const countryMetaById = new Map(
  world.features
    .map((geo) => {
      const id = Number(geo.id);
      const code = isoCountries.numericToAlpha2(id);
      const name = code ? isoCountries.getName(code, 'en') : null;
      return {
        id,
        code,
        name: name || geo.properties?.name || 'Unknown',
      };
    })
    .filter((country) => Number.isFinite(country.id))
    .map((country) => [country.id, country])
);
---

<section class="card travel-map">
  <div class="flex flex-col gap-6">
    <div class="flex flex-col gap-2">
      <p class="text-sm uppercase tracking-[0.25em] text-text-muted">Travel Ledger</p>
      <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
        <h2 class="text-3xl md:text-4xl font-heading font-bold">From hometown to home base</h2>
        <div class="text-sm text-text-muted">
          {visitedCount} of {totalCountries} countries visited ({progressPercent}%)
        </div>
      </div>
      <div class="progress-track">
        <div class="progress-fill" style={`width: ${progressPercent}%;`}></div>
      </div>
    </div>

    <div class="map-shell" data-travel-map>
      <div class="map-controls">
        <button class="map-control" type="button" data-zoom-in aria-label="Zoom in">+</button>
        <button class="map-control" type="button" data-zoom-out aria-label="Zoom out">−</button>
        <button class="map-control" type="button" data-zoom-reset>Reset view</button>
        <span class="map-zoom-level" data-zoom-level>1.0×</span>
      </div>
      <div class="map-hint">
        <span class="map-hint-desktop">Scroll or double-click to zoom • Drag to pan</span>
        <span class="map-hint-mobile">Pinch to zoom • Drag to pan</span>
      </div>
      <svg
        class="map-svg"
        tabindex="0"
        viewBox={`0 0 ${width} ${height}`}
        role="img"
        aria-label="World map highlighting countries visited and cities lived"
      >
        <g class="map-zoom-layer" data-zoom-layer>
          <g class="map-countries">
            {world.features.map((geo) => {
              const id = Number(geo.id);
              const note = countryNotesById.get(id);
              const meta = countryMetaById.get(id);
              return (
              <path
                d={path(geo)}
                class:list={[
                  'map-country',
                  visitedIds.has(id) && 'is-visited',
                  note && 'has-note',
                ]}
                data-country={geo.id}
                data-name={meta?.name}
                data-note={note ? JSON.stringify(note) : undefined}
                data-has-note={note ? 'true' : undefined}
                tabindex={note ? '0' : undefined}
                role={note ? 'button' : undefined}
                aria-label={note ? `${meta?.name ?? 'Country'} notes` : undefined}
              />
            )})}
          </g>
          <g class="map-markers">
            {markers.map((marker) => (
              <g
                class:list={[
                  'map-marker',
                  marker.type === 'current_base' && 'is-current',
                  marker.type === 'hometown' && 'is-hometown',
                  marker.type === 'favorite' && 'is-favorite',
                ]}
                data-city-marker
                data-city={marker.city}
                data-country={marker.country}
                data-dates={marker.dates ?? ''}
                data-title={marker.title ?? ''}
                data-note={marker.note ?? ''}
                data-type={marker.type}
                tabindex="0"
                role="button"
                aria-label={`${marker.city}, ${marker.country}`}
              >
                <circle class="marker-ring" cx={marker.x} cy={marker.y} r="6"></circle>
                <circle class="marker-core" cx={marker.x} cy={marker.y} r="3"></circle>
                {marker.type === 'current_base' && (
                  <circle class="marker-pulse" cx={marker.x} cy={marker.y} r="10"></circle>
                )}
              </g>
            ))}
          </g>
        </g>
      </svg>

      <div class="map-tooltip" data-travel-tooltip aria-live="polite"></div>
      <div class="map-label" data-country-label aria-hidden="true"></div>
    </div>

    <div class="grid gap-4 md:grid-cols-4 text-sm text-text-muted">
      <div class="flex items-center gap-2">
        <span class="legend-dot legend-visited"></span>
        Countries visited
      </div>
      <div class="flex items-center gap-2">
        <span class="legend-dot legend-lived"></span>
        Cities lived
      </div>
      <div class="flex items-center gap-2">
        <span class="legend-dot legend-current"></span>
        Current base
      </div>
      <div class="flex items-center gap-2">
        <span class="legend-dot legend-favorite"></span>
        Favorite places
      </div>
    </div>
  </div>
</section>

<style>
  .travel-map {
    --map-visited: var(--color-primary);
    --map-visited-hover: var(--color-primary-hover);
    --map-visited-soft: rgba(99, 102, 241, 0.55);
    --map-unvisited: #171717;
    --map-unvisited-hover: #202020;
    --map-stroke: rgba(255, 255, 255, 0.06);
    --marker-lived: #22d3ee;
    --marker-hometown: #f59e0b;
    --marker-current: #f97316;
    --marker-favorite: #ec4899;
    display: block;
  }

  .progress-track {
    width: 100%;
    height: 6px;
    border-radius: 999px;
    background: var(--color-surface-hover);
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
    transition: width 0.6s ease;
  }

  .map-shell {
    position: relative;
    border-radius: 16px;
    background:
      radial-gradient(circle at top, rgba(99, 102, 241, 0.14), transparent 60%),
      linear-gradient(180deg, rgba(12, 12, 16, 0.95), rgba(8, 8, 8, 0.95));
    padding: 1rem;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.04);
  }

  .map-svg {
    width: 100%;
    height: auto;
    display: block;
    touch-action: none;
    cursor: grab;
    outline: none;
  }

  .map-svg.is-panning {
    cursor: grabbing;
  }

  .map-svg:focus-visible {
    outline: 2px solid rgba(99, 102, 241, 0.6);
    outline-offset: 4px;
  }

  .map-country {
    fill: var(--map-unvisited);
    stroke: var(--map-stroke);
    stroke-width: 0.6;
    transition: fill 0.2s ease, stroke 0.2s ease;
  }

  .map-country.is-visited {
    fill: var(--map-visited-soft);
    stroke: rgba(99, 102, 241, 0.2);
  }

  .map-country.has-note {
    stroke: rgba(99, 102, 241, 0.35);
    stroke-width: 1;
    cursor: pointer;
  }

  .map-country:hover {
    fill: var(--map-unvisited-hover);
  }

  .map-country.is-visited:hover {
    fill: var(--map-visited-hover);
  }

  .map-markers {
  }

  .map-marker {
    pointer-events: all;
    cursor: pointer;
  }

  .marker-ring {
    fill: transparent;
    stroke: var(--marker-lived);
    stroke-width: 2;
    opacity: 0.7;
  }

  .marker-core {
    fill: var(--marker-lived);
  }

  .map-marker.is-hometown .marker-ring,
  .map-marker.is-hometown .marker-core {
    stroke: var(--marker-hometown);
    fill: var(--marker-hometown);
  }

  .map-marker.is-current .marker-ring,
  .map-marker.is-current .marker-core {
    stroke: var(--marker-current);
    fill: var(--marker-current);
  }

  .map-marker.is-favorite .marker-ring,
  .map-marker.is-favorite .marker-core {
    stroke: var(--marker-favorite);
    fill: var(--marker-favorite);
  }

  .marker-pulse {
    fill: rgba(249, 115, 22, 0.15);
    animation: pulse 2.5s ease-out infinite;
  }

  .map-controls {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 2;
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .map-control {
    background: rgba(20, 20, 20, 0.85);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: var(--color-text);
    font-size: 0.75rem;
    padding: 0.45rem 0.75rem;
    border-radius: 999px;
    transition: border-color 0.2s ease, transform 0.2s ease;
  }

  .map-control:hover {
    border-color: rgba(99, 102, 241, 0.6);
    transform: translateY(-1px);
  }

  .map-zoom-level {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    padding-left: 0.25rem;
  }

  .map-hint {
    position: absolute;
    left: 1rem;
    bottom: 1rem;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    background: rgba(15, 15, 15, 0.75);
    padding: 0.35rem 0.6rem;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    z-index: 2;
  }

  .map-hint-mobile {
    display: none;
  }

  @media (max-width: 768px) {
    .map-hint-desktop {
      display: none;
    }

    .map-hint-mobile {
      display: inline;
    }
  }

  .map-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-50%, -120%);
    min-width: 180px;
    max-width: 240px;
    padding: 0.75rem 0.9rem;
    border-radius: 12px;
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: var(--color-text);
    font-size: 0.85rem;
    line-height: 1.4;
    box-shadow: 0 16px 40px -20px rgba(0, 0, 0, 0.6);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease, transform 0.2s ease;
  }

  .map-tooltip.is-visible {
    opacity: 1;
    transform: translate(-50%, -130%);
  }

  .map-tooltip strong {
    display: block;
    font-size: 0.95rem;
    margin-bottom: 0.15rem;
  }

  .map-label {
    position: absolute;
    padding: 0.4rem 0.6rem;
    border-radius: 999px;
    background: rgba(15, 15, 15, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: var(--color-text);
    font-size: 0.75rem;
    letter-spacing: 0.02em;
    opacity: 0;
    transform: translate(-50%, -120%);
    pointer-events: none;
    transition: opacity 0.15s ease, transform 0.15s ease;
    z-index: 2;
  }

  .map-label.is-visible {
    opacity: 1;
    transform: translate(-50%, -135%);
  }

  .map-label.is-flash {
    animation: labelFlash 0.45s ease;
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 999px;
    display: inline-block;
  }

  .legend-visited {
    background: var(--map-visited);
  }

  .legend-lived {
    background: var(--marker-lived);
  }

  .legend-current {
    background: var(--marker-current);
  }

  .legend-favorite {
    background: var(--marker-favorite);
  }

  @keyframes pulse {
    0% {
      r: 6;
      opacity: 0.6;
    }
    70% {
      r: 14;
      opacity: 0;
    }
    100% {
      r: 14;
      opacity: 0;
    }
  }

  @keyframes labelFlash {
    0% {
      box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.35);
    }
    100% {
      box-shadow: 0 0 0 10px rgba(99, 102, 241, 0);
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .progress-fill,
    .map-country,
    .map-tooltip,
    .marker-pulse,
    .map-label {
      transition: none;
      animation: none;
    }
  }
</style>

<script is:inline>
  const map = document.querySelector('[data-travel-map]');
  const tooltip = map?.querySelector('[data-travel-tooltip]');
  const label = map?.querySelector('[data-country-label]');
  const svg = map?.querySelector('svg');
  const zoomLayer = svg?.querySelector('[data-zoom-layer]');
  const resetButton = map?.querySelector('[data-zoom-reset]');
  const zoomInButton = map?.querySelector('[data-zoom-in]');
  const zoomOutButton = map?.querySelector('[data-zoom-out]');
  const zoomLevel = map?.querySelector('[data-zoom-level]');
  const markers = map?.querySelectorAll('[data-city-marker]') || [];
  const countries = map?.querySelectorAll('[data-country]') || [];

  if (map && tooltip && svg) {
    let pinnedMarker = null;
    let pinnedCountry = null;
    let labelTimeout = null;

    const setTooltipContent = (marker) => {
      const city = marker.dataset.city;
      const country = marker.dataset.country;
      const dates = marker.dataset.dates;
      const title = marker.dataset.title;
      const note = marker.dataset.note;

      tooltip.innerHTML = `
        <strong>${title || `${city}, ${country}`}</strong>
        ${title ? `<div class="text-text-muted">${city}, ${country}</div>` : ''}
        ${dates ? `<div>${dates}</div>` : ''}
        ${note ? `<div class="text-text-muted">${note}</div>` : ''}
      `;
    };

    const positionTooltip = (marker) => {
      const circle = marker.querySelector('circle');
      if (!circle) return;
      const circleRect = circle.getBoundingClientRect();
      const mapRect = map.getBoundingClientRect();

      const left = circleRect.left - mapRect.left + circleRect.width / 2;
      const top = circleRect.top - mapRect.top;
      tooltip.style.left = `${left}px`;
      tooltip.style.top = `${top}px`;
    };

    const showTooltip = (marker) => {
      setTooltipContent(marker);
      positionTooltip(marker);
      tooltip.classList.add('is-visible');
    };

    const hideTooltip = () => {
      if (pinnedMarker || pinnedCountry) return;
      tooltip.classList.remove('is-visible');
    };

    const showLabel = (event, text) => {
      if (!label) return;
      label.textContent = text;
      label.classList.add('is-visible', 'is-flash');
      if (labelTimeout) {
        window.clearTimeout(labelTimeout);
      }
      labelTimeout = window.setTimeout(() => {
        label.classList.remove('is-flash');
      }, 450);
      moveLabel(event);
    };

    const moveLabel = (event) => {
      if (!label) return;
      const mapRect = map.getBoundingClientRect();
      label.style.left = `${event.clientX - mapRect.left}px`;
      label.style.top = `${event.clientY - mapRect.top}px`;
    };

    const hideLabel = () => {
      if (!label) return;
      label.classList.remove('is-visible');
    };

    markers.forEach((marker) => {
      marker.addEventListener('mouseenter', () => {
        if (pinnedMarker && pinnedMarker !== marker) return;
        showTooltip(marker);
      });

      marker.addEventListener('mouseleave', () => {
        if (pinnedMarker && pinnedMarker !== marker) return;
        hideTooltip();
      });

      marker.addEventListener('focus', () => {
        showTooltip(marker);
      });

      marker.addEventListener('blur', () => {
        if (pinnedMarker && pinnedMarker !== marker) return;
        hideTooltip();
      });

      marker.addEventListener('click', () => {
        if (pinnedMarker === marker) {
          pinnedMarker = null;
          hideTooltip();
          return;
        }
        pinnedCountry = null;
        pinnedMarker = marker;
        showTooltip(marker);
      });
    });

    countries.forEach((country) => {
      const name = country.getAttribute('data-name') || '';
      country.addEventListener('mouseenter', (event) => {
        if (name) showLabel(event, name);
      });

      country.addEventListener('mousemove', (event) => {
        if (name) moveLabel(event);
      });

      country.addEventListener('mouseleave', () => {
        hideLabel();
      });

      const noteJson = country.getAttribute('data-note');
      if (!noteJson) return;

      const note = JSON.parse(noteJson);
      if (!note) return;

      const showCountryTooltip = () => {
        const countryRect = country.getBoundingClientRect();
        const mapRect = map.getBoundingClientRect();
        const left = countryRect.left - mapRect.left + countryRect.width / 2;
        const top = countryRect.top - mapRect.top;

        tooltip.innerHTML = `
          <strong>${note.title || note.name}</strong>
          ${note.note ? `<div class="text-text-muted">${note.note}</div>` : ''}
        `;

        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
        tooltip.classList.add('is-visible');
      };

      country.addEventListener('mouseenter', () => {
        if (pinnedMarker || pinnedCountry) return;
        showCountryTooltip();
      });

      country.addEventListener('mouseleave', () => {
        if (pinnedMarker || pinnedCountry) return;
        hideTooltip();
      });

      country.addEventListener('focus', () => {
        showCountryTooltip();
      });

      country.addEventListener('blur', () => {
        if (pinnedCountry) return;
        hideTooltip();
      });

      country.addEventListener('click', () => {
        if (pinnedCountry === country) {
          pinnedCountry = null;
          hideTooltip();
          return;
        }
        pinnedMarker = null;
        pinnedCountry = country;
        showCountryTooltip();
      });
    });

    document.addEventListener('click', (event) => {
      if (!map.contains(event.target)) {
        pinnedMarker = null;
        pinnedCountry = null;
        hideTooltip();
        hideLabel();
      }
    });

    window.addEventListener('resize', () => {
      if (pinnedMarker) {
        positionTooltip(pinnedMarker);
      }
    });

    if (zoomLayer) {
      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
      const baseViewBox = svg.getAttribute('viewBox')?.split(' ').map(Number);
      if (!baseViewBox || baseViewBox.length !== 4) return;

      const base = {
        x: baseViewBox[0],
        y: baseViewBox[1],
        width: baseViewBox[2],
        height: baseViewBox[3],
      };

      let current = { ...base };
      let isPanning = false;
      let startX = 0;
      let startY = 0;
      let startViewBox = { ...base };
      let lastMoveTime = 0;
      let velocityX = 0;
      let velocityY = 0;
      let inertiaFrame = null;

      const updateZoomLevel = () => {
        if (!zoomLevel) return;
        const scale = base.width / current.width;
        zoomLevel.textContent = `${scale.toFixed(1)}×`;
      };

      const applyViewBox = () => {
        current.width = clamp(current.width, base.width / 2.8, base.width);
        current.height = clamp(current.height, base.height / 2.8, base.height);
        current.x = clamp(current.x, base.x, base.x + base.width - current.width);
        current.y = clamp(current.y, base.y, base.y + base.height - current.height);
        svg.setAttribute(
          'viewBox',
          `${current.x} ${current.y} ${current.width} ${current.height}`
        );
        updateZoomLevel();
      };

      const toViewBoxPoint = (clientX, clientY) => {
        const rect = svg.getBoundingClientRect();
        const x = ((clientX - rect.left) / rect.width) * current.width + current.x;
        const y = ((clientY - rect.top) / rect.height) * current.height + current.y;
        return { x, y };
      };

      const zoomTo = (nextScale, point) => {
        const clampedScale = clamp(nextScale, 1, 2.8);
        const newWidth = base.width / clampedScale;
        const newHeight = base.height / clampedScale;
        const relX = (point.x - current.x) / current.width;
        const relY = (point.y - current.y) / current.height;
        current.x = point.x - relX * newWidth;
        current.y = point.y - relY * newHeight;
        current.width = newWidth;
        current.height = newHeight;
        applyViewBox();
      };

      svg.addEventListener(
        'wheel',
        (event) => {
          event.preventDefault();
          const delta = -event.deltaY * 0.0012;
          const scale = base.width / current.width;
          const point = toViewBoxPoint(event.clientX, event.clientY);
          zoomTo(scale + delta, point);
        },
        { passive: false }
      );

      svg.addEventListener('pointerdown', (event) => {
        if (event.button !== 0) return;
        if (event.target.closest('[data-city-marker]')) return;
        isPanning = true;
        svg.setPointerCapture(event.pointerId);
        svg.classList.add('is-panning');
        startX = event.clientX;
        startY = event.clientY;
        startViewBox = { ...current };
        lastMoveTime = performance.now();
        velocityX = 0;
        velocityY = 0;
        if (inertiaFrame) {
          cancelAnimationFrame(inertiaFrame);
          inertiaFrame = null;
        }
      });

      svg.addEventListener('pointermove', (event) => {
        if (!isPanning) return;
        const rect = svg.getBoundingClientRect();
        const unitX = current.width / rect.width;
        const unitY = current.height / rect.height;
        const dx = (event.clientX - startX) * unitX;
        const dy = (event.clientY - startY) * unitY;
        current.x = startViewBox.x - dx;
        current.y = startViewBox.y - dy;
        const now = performance.now();
        const dt = Math.max(now - lastMoveTime, 16);
        velocityX = (event.movementX * unitX) / dt;
        velocityY = (event.movementY * unitY) / dt;
        lastMoveTime = now;
        applyViewBox();
      });

      const endPan = (event) => {
        if (!isPanning) return;
        isPanning = false;
        svg.classList.remove('is-panning');
        svg.releasePointerCapture(event.pointerId);

        const speed = Math.hypot(velocityX, velocityY);
        if (speed > 0.002) {
          const decay = 0.92;
          const step = () => {
            velocityX *= decay;
            velocityY *= decay;
            current.x -= (velocityX * 16);
            current.y -= (velocityY * 16);
            applyViewBox();
            if (Math.hypot(velocityX, velocityY) > 0.002) {
              inertiaFrame = requestAnimationFrame(step);
            } else {
              inertiaFrame = null;
            }
          };
          inertiaFrame = requestAnimationFrame(step);
        }
      };

      svg.addEventListener('pointerup', endPan);
      svg.addEventListener('pointercancel', endPan);

      svg.addEventListener('dblclick', (event) => {
        event.preventDefault();
        const scale = base.width / current.width;
        const point = toViewBoxPoint(event.clientX, event.clientY);
        zoomTo(scale + (event.shiftKey ? -0.4 : 0.4), point);
      });

      svg.addEventListener('keydown', (event) => {
        const scale = base.width / current.width;
        if (event.key === '+' || event.key === '=') {
          event.preventDefault();
          const point = { x: current.x + current.width / 2, y: current.y + current.height / 2 };
          zoomTo(scale + 0.3, point);
        }

        if (event.key === '-' || event.key === '_') {
          event.preventDefault();
          const point = { x: current.x + current.width / 2, y: current.y + current.height / 2 };
          zoomTo(scale - 0.3, point);
        }

        if (event.key === '0') {
          event.preventDefault();
          current = { ...base };
          applyViewBox();
        }
      });

      zoomInButton?.addEventListener('click', () => {
        const scale = base.width / current.width;
        const point = { x: current.x + current.width / 2, y: current.y + current.height / 2 };
        zoomTo(scale + 0.3, point);
      });

      zoomOutButton?.addEventListener('click', () => {
        const scale = base.width / current.width;
        const point = { x: current.x + current.width / 2, y: current.y + current.height / 2 };
        zoomTo(scale - 0.3, point);
      });

      resetButton?.addEventListener('click', () => {
        current = { ...base };
        applyViewBox();
      });

      applyViewBox();
    }
  }
</script>
